state는 별도의 함수로 변경

돔을 다시 재조작하는 것은 메모리 성능 저하시키는 요인
동적인 요소를 많이 넣으면 웹페이지 기능의 속도가 느려지고 다운될 수 있었다.

가상의 돔을 이용
기존의 돔에서 변경사항이 발생하면 기존의 것을 날리고 변경된 가상의 돔을 대체 입력

Render을 이용하여 변경사항에 대한 화면 업데이트 동작 수행 

리액트에서는 변경의 효율성을 위해
객체의 자원의 주소값만 비교해서 값을 변경
- > 객체의 자원의 주소값이 바뀌여야지만(=새로운 객체 생성) 갱신(값의 변경)이 이루어짐
기존에 있던 객체의 주소값과 변경된 객체의 주소값을 비교해보고 다르면 값의 변경 실행

props: 부모 컴포넌트에서 넘겨준 값
state : 상태값; 현재 컴포넌트 내에서 사용할 값 

클래스형 컴포넌트 : 랜더형 함수 호출
함수형 컴포넌트 : state 값이 있지만 변경을 위한 별도의 함수 제공 - hook ; useState (비구조화할당 문법)

setData - 새로운 객체 생성을 도와주는 기능 
...data - 기존 데이터를 복사 하고 변경된 부분만 업데이트

forceUpdate() -> 코드를 잘 못짜면 자주 쓰게 되는 기능, 강제적으로 갱신을 동작시키기 때문
객체값은 다르지만 주소값이 같아서 렌더링이 작동되지 않을 때 쓰임 


*비구조화 할당

지역 내에서; 함수 내에서 이벤트 처리기를 사용하는 건 괜찮 0 
전역 내에서 window 환경내에서 이벤트 처리기 사용 비추

메모리에 대한 이해 stack -> 밑에가 막혀있는 원통형 구조

정적 메모리(한번 설정되면, 변경 X)
 -데이터 영역
   - 변경되지 않는 부분
   - 작성한 코드
   - 상수
   - 메서드...

동적 메모리
- 스택 영역
- 힙 영역


이벤트 리스너 안의 this -> 의미있게 변경 어케? -> 이벤트가 부여된 도큐멘트 객체로 바뀌어 있다 

target - > 이벤트가 발생한 요소; 실제 클릭한 요소

current target - > 이벤트가 바인딩된 요소; 이벤트를 등록한 요소 === this와 같다

화살표 함수로 정의하는 순간 this는 윈도우를 가르킨다